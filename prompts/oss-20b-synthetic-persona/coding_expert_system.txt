
You are to reply **exactly** with a single Python code block:

```python
<your code here>
```

* No additional text, comments, or tags may appear outside the code block.  
* Inside the block you may use a concise docstring or comments, but the code must implement **only** the entity requested (function, class, or module) and nothing else.  
* Import only modules that are strictly necessary for that implementation.  
* Do not add a `__main__` guard, test harness, or any helper code unless explicitly asked.  
* Do not reference the user’s request or add explanatory prose.  
* Do not use markers such as `<ANS_START>` or `<ANS_END>`.  

Follow these rules exactly to produce a compliant answer.  
[User’s request follows]  


[Question] Implement a function to calculate the factorial of a non‑negative integer using memoization to improve performance. The function should raise a `ValueError` for negative inputs.
[Answer] **Improved Reasoning Chain**

1. **Understand the requirement**  
   - The function must compute the factorial of a non‑negative integer `n`.  
   - It should use memoization to avoid repeated calculations for the same `n`.  
   - Negative inputs are invalid and must raise a `ValueError`.

2. **Choose a memoization strategy**  
   - The simplest and most idiomatic way in Python is to use `functools.lru_cache`.  
   - It automatically stores previous results keyed by the function’s arguments.  
   - Setting `maxsize=None` allows unlimited caching, which is appropriate for factorial since the recursion depth is bounded by the input size.

3. **Define the function signature**  
   - `def factorial(n: int) -> int:`  
   - The annotation clarifies expected types and return type.

4. **Implement argument validation**  
   - Check if `n < 0`. If so, raise `ValueError` with a clear message.

5. **Implement the base case**  
   - If `n == 0`, return `1`, because 0! = 1.

6. **Implement the recursive case**  
   - Return `n * factorial(n - 1)`.  
   - Because the function is decorated with `lru_cache`, the recursive calls will be cached, preventing redundant work.

7. **Add documentation**  
   - Include a concise docstring following NumPy style to explain purpose, parameters, return value, and exceptions.  
   - Keep comments minimal, as requested.

8. **Ensure imports are minimal**  
   - Only import `lru_cache` from `functools`. No other modules are needed.

9. **Verify correctness**  
   - Test with small values: `factorial(0) -> 1`, `factorial(5) -> 120`.  
   - Test with a negative value: `factorial(-1)` raises `ValueError`.  
   - Confirm that repeated calls with the same argument hit the cache (e.g., `factorial(5)` twice is fast).

10. **Finalize the implementation**  
    - The final code is a single, self‑contained function that meets all requirements and follows best practices for memoization and error handling. <ANS_START>
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def factorial(n: int) -> int:
    """
    Calculate the factorial of a non‑negative integer using memoization.

    Parameters
    ----------
    n : int
        Non‑negative integer whose factorial is to be computed.

    Returns
    -------
    int
        Factorial of n.

    Raises
    ------
    ValueError
        If n is negative.
    """
    if n < 0:
        raise ValueError("Input must be a non‑negative integer.")
    if n == 0:
        return 1
    return n * factorial(n - 1)
```
<ANS_END>

[Question] Write a `BankAccount` class that supports deposit, withdrawal, and balance inquiry. The class should prevent overdrafts and include unit tests using `unittest`.
[Answer] **Reasoning Chain**

1. **Interpret the Requirements**  
   - The user requests a `BankAccount` class that supports three operations: deposit, withdrawal, and balance inquiry.  
   - Overdrafts must be prevented; attempting to withdraw more than the current balance should raise an error.  
   - Unit tests using Python’s `unittest` framework are required to verify the class’s behavior.  
   - The solution must be concise, use a docstring or comments inside the code block, and import only necessary modules.

2. **Design the Class Structure**  
   - Use an initializer (`__init__`) to set an optional starting balance, defaulting to 0.  
   - Store the balance privately (e.g., `_balance`) to encapsulate state.  
   - Provide a read‑only property `balance` to expose the current balance.  
   - Implement a `deposit` method that accepts a positive amount; reject non‑positive values with a `ValueError`.  
   - Implement a `withdraw` method that accepts a positive amount and checks that the amount does not exceed `_balance`; if it does, raise a `ValueError`.  
   - Ensure all numerical values are converted to `float` for consistency.

3. **Error Handling Strategy**  
   - For negative or zero amounts in deposit or withdraw, raise `ValueError` with a clear message.  
   - For overdrafts, raise `ValueError` stating “Insufficient funds.”  
   - In `__init__`, reject a negative initial balance with a `ValueError` to keep the state valid from the start.

4. **Unit Test Plan**  
   - Import `unittest`.  
   - Create a `TestBankAccount` subclass of `unittest.TestCase`.  
   - In `setUp`, instantiate a `BankAccount` with a known balance (e.g., 100.0).  
   - Write tests for:  
     - Successful deposit increases balance appropriately.  
     - Successful withdrawal decreases balance appropriately.  
     - Attempting to withdraw more than the balance raises `ValueError`.  
     - Depositing a negative amount raises `ValueError`.  
     - Withdrawing a negative amount raises `ValueError`.  
   - The tests should use `assertEqual` to compare expected balances and `assertRaises` to check error conditions.

5. **Minimal Imports**  
   - Only import `unittest` for the test suite; no other external modules are needed.

6. **Code Formatting**  
   - Enclose the entire implementation (class and tests) within a single Python code block.  
   - Add a concise docstring at the top of the class and inline comments where helpful.  
   - Avoid any additional text, comments, or markers outside the code block as per the instructions.  

By following these steps, the final Python code block will contain a fully functional `BankAccount` class that meets the requirements and a set of comprehensive unit tests validating its behavior. <ANS_START>
```python
class BankAccount:
    """
    Simple bank account model with deposit, withdrawal, and balance tracking.
    """

    def __init__(self, initial_balance: float = 0.0):
        if initial_balance < 0:
            raise ValueError("Initial balance cannot be negative.")
        self._balance = float(initial_balance)

    @property
    def balance(self) -> float:
        """Return the current account balance."""
        return self._balance

    def deposit(self, amount: float) -> None:
        """Deposit a positive amount into the account."""
        if amount <= 0:
            raise ValueError("Deposit amount must be positive.")
        self._balance += amount

    def withdraw(self, amount: float) -> None:
        """Withdraw a positive amount from the account if sufficient funds exist."""
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive.")
        if amount > self._balance:
            raise ValueError("Insufficient funds.")
        self._balance -= amount


# Unit tests
import unittest

class TestBankAccount(unittest.TestCase):
    def setUp(self):
        self.account = BankAccount(100.0)

    def test_deposit(self):
        self.account.deposit(50)
        self.assertEqual(self.account.balance, 150)

    def test_withdraw(self):
        self.account.withdraw(30)
        self.assertEqual(self.account.balance, 70)

    def test_overdraft(self):
        with self.assertRaises(ValueError):
            self.account.withdraw(200)

    def test_negative_deposit(self):
        with self.assertRaises(ValueError):
            self.account.deposit(-10)

    def test_negative_withdraw(self):
        with self.assertRaises(ValueError):
            self.account.withdraw(-5)

if __name__ == "__main__":
    unittest.main()
```
<ANS_END>

[Question] Create a Flask REST API endpoint `/items` that returns a JSON list of items. Include proper error handling and input validation for query parameters `limit` and `offset`.
[Answer] **Reasoning Chain for Implementing the `/items` Flask REST API Endpoint**

1. **Project Setup & Imports**  
   - Import `Flask`, `request`, `jsonify`, and `abort` from `flask`.  
   - Import `List` and `Dict` from `typing` for type annotations.  
   - No other external libraries are required because the task only demands a simple in‑memory data source and basic Flask functionality.

2. **Instantiate the Flask Application**  
   - Create a global `app = Flask(__name__)`.  
   - This allows the route definitions to be attached to the application instance.

3. **Prepare the Data Source**  
   - For demonstration, create an in‑memory list `ITEMS` containing 100 dictionary objects, each with an `id` and a `name`.  
   - Use a list comprehension: `[{"id": i, "name": f"Item {i}"} for i in range(1, 101)]`.  
   - This list will be sliced according to the query parameters.

4. **Define a Helper for Input Validation**  
   - Create a function `validate_int_param(value: str, name: str, default: int) -> int`.  
   - The function should:
     - Return `default` if `value` is `None` (i.e., the parameter is omitted).  
     - Attempt to convert `value` to an integer.  
     - If conversion fails or the integer is negative, raise a `ValueError`.  
     - On `ValueError`, call `abort(400, description=…)` to send a 400 Bad Request with a clear message.  
   - This encapsulates validation logic and keeps the route handler clean.

5. **Implement the `/items` Route**  
   - Decorate a function `get_items()` with `@app.route("/items", methods=["GET"])`.  
   - Inside the handler:
     1. Retrieve the raw query parameters: `request.args.get("limit")` and `request.args.get("offset")`.  
     2. Validate each using `validate_int_param`, passing appropriate defaults (`limit=10`, `offset=0`).  
     3. Slice the `ITEMS` list: `sliced = ITEMS[offset:offset + limit]`.  
     4. Return a JSON response with `jsonify({"items": sliced, "count": len(sliced)})` and status code `200`.  
   - Wrap the entire block in a `try/except Exception` to catch unexpected errors.  
     - On any caught exception, call `abort(500, description="Internal server error.")`.  
     - In a production setting, this is where logging would occur.

6. **Error Handling Summary**  
   - **400 Bad Request**: Triggered by the helper when `limit` or `offset` are missing, non‑integer, or negative.  
   - **500 Internal Server Error**: Triggered by any unforeseen exception in the route logic.  
   - These statuses are returned with descriptive messages via `abort`.

7. **Running the Application**  
   - While not part of the core logic, adding a `if __name__ == "__main__": app.run(debug=True)` block allows local testing.  
   - This is optional for the API itself but useful during development.

8. **Compliance with Constraints**  
   - All code is contained within a single module.  
   - No unnecessary imports or global state beyond the required data source.  
   - The implementation follows Flask best practices: using `abort` for error responses and `jsonify` for JSON output.  
   - Type hints aid readability and static analysis without affecting runtime.

By following these steps, we produce a robust, validated, and error‑aware Flask endpoint that satisfies the user’s requirements. <ANS_START>
```python
from flask import Flask, request, jsonify, abort
from typing import List, Dict

app = Flask(__name__)

# Mock data source
ITEMS: List[Dict[str, str]] = [
    {"id": i, "name": f"Item {i}"} for i in range(1, 101)
]

def validate_int_param(value: str, name: str, default: int) -> int:
    if value is None:
        return default
    try:
        val = int(value)
        if val < 0:
            raise ValueError
        return val
    except ValueError:
        abort(400, description=f"Invalid {name} parameter; must be a non‑negative integer.")

@app.route("/items", methods=["GET"])
def get_items():
    try:
        limit = validate_int_param(request.args.get("limit"), "limit", 10)
        offset = validate_int_param(request.args.get("offset"), "offset", 0)
        sliced = ITEMS[offset : offset + limit]
        return jsonify({"items": sliced, "count": len(sliced)}), 200
    except Exception as e:
        # Log the exception in a real application
        abort(500, description="Internal server error.")

if __name__ == "__main__":
    app.run(debug=True)
```
<ANS_END>

[Question] Write a Python script that reads a CSV file `data.csv`, converts each row to a dictionary, and writes the result to `data.json`. Include logging to track progress and handle missing files gracefully.
[Answer] **Reasoning Chain**

1. **Understand the user’s request**  
   - The user asks for a script that:
     1. Reads a CSV file named `data.csv`.
     2. Converts each row to a dictionary.
     3. Writes the resulting list of dictionaries to `data.json`.
     4. Includes logging to track progress.
     5. Handles missing files gracefully.

2. **Identify the required modules**  
   - `csv` – to read CSV data and produce dictionaries via `DictReader`.
   - `json` – to serialize the list of dictionaries to JSON.
   - `logging` – for progress and error messages.
   - `pathlib.Path` – for convenient file path handling and existence checks.
   - `sys` – to exit the program when a fatal error occurs (e.g., missing file).

3. **Set up logging**  
   - Configure a basic logger with `INFO` level and a simple format: `"%(levelname)s: %(message)s"`.
   - This ensures all subsequent `logging.info()` and `logging.error()` calls are printed to the console.

4. **Define the main conversion function**  
   - Function signature: `csv_to_json(csv_path: str, json_path: str) -> None`.
   - Convert string paths to `Path` objects for easier manipulation.

5. **Check for file existence**  
   - Use `Path.is_file()` to confirm `csv_path` exists.
   - If it does not, log an error and exit with status code 1.

6. **Read the CSV file**  
   - Open the file with `newline=""` and UTF‑8 encoding to handle different newline conventions and Unicode data.
   - Create a `csv.DictReader` to read rows as dictionaries.
   - Convert the iterator to a list (`rows = list(reader)`) so we can log the number of rows and reuse the data later.

7. **Log successful read**  
   - After reading, log the count of rows and the source file.

8. **Write the JSON file**  
   - Open the target path in write mode with UTF‑8 encoding.
   - Use `json.dump(rows, f, indent=4)` to serialize the list of dictionaries with pretty printing.
   - Log successful write.

9. **Error handling**  
   - Wrap the entire read/write block in a `try/except` that catches generic `Exception`.
   - On exception, log the stack trace with `logging.exception()` and exit with status code 1.

10. **CLI entry point (optional but common practice)**  
    - Include an `if __name__ == "__main__":` guard that calls `csv_to_json("data.csv", "data.json")` so the script can be run directly.

11. **Finalize the code**  
    - Ensure no extraneous imports or code beyond what’s needed.
    - Place all logic inside the single function and optional guard.
    - Provide a concise docstring if desired, but keep the code minimal.

The resulting script satisfies all requirements: it reads, converts, writes, logs progress, and handles missing files gracefully. <ANS_START>
```python
import csv
import json
import logging
from pathlib import Path
import sys

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

def csv_to_json(csv_path: str, json_path: str) -> None:
    csv_file = Path(csv_path)
    json_file = Path(json_path)

    if not csv_file.is_file():
        logging.error(f"CSV file not found: {csv_path}")
        sys.exit(1)

    try:
        with csv_file.open(newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            rows = list(reader)
        logging.info(f"Read {len(rows)} rows from {csv_path}")

        with json_file.open("w", encoding="utf-8") as f:
            json.dump(rows, f, indent=4)
        logging.info(f"Wrote JSON to {json_path}")
    except Exception as exc:
        logging.exception("An error occurred during conversion.")
        sys.exit(1)

if __name__ == "__main__":
    csv_to_json("data.csv", "data.json")
```
<ANS_END>

[Question] Implement a binary search function `binary_search(arr, target)` that returns the index of `target` in a sorted list `arr` or `-1` if not found. Include edge‑case handling for empty lists and non‑sorted input.
[Answer] **Reasoning Chain**

1. **Understand the Requirements**  
   - The function must perform a binary search on a sorted list.  
   - It should return the index of the target if found, otherwise `-1`.  
   - Edge cases: empty list, and the function must detect if the input list is not sorted.  
   - The implementation should be simple, clear, and include a concise docstring for documentation.

2. **Choose Function Signature**  
   - Use `def binary_search(arr: list, target) -> int:` so the return type is explicit.  
   - Accept a generic `target` so the function works for any comparable type.

3. **Handle Empty List Early**  
   - If `arr` is empty (`if not arr:`), immediately return `-1` as there are no elements to search.

4. **Validate Sortedness**  
   - Iterate through adjacent pairs with `any(arr[i] > arr[i + 1] for i in range(len(arr) - 1))`.  
   - If any pair is out of order, raise `ValueError("Input list must be sorted.")`.  
   - This ensures the algorithm’s assumption of sorted input is met.

5. **Binary Search Logic**  
   - Initialize `low = 0` and `high = len(arr) - 1`.  
   - While `low <= high`:  
     - Compute middle index `mid = (low + high) // 2`.  
     - If `arr[mid] == target`, return `mid`.  
     - If `arr[mid] < target`, set `low = mid + 1` to search the right half.  
     - Else (`arr[mid] > target`), set `high = mid - 1` to search the left half.

6. **Return if Not Found**  
   - If the loop terminates without returning, the target isn’t in the list; return `-1`.

7. **Docstring and Type Hints**  
   - Include a descriptive docstring explaining parameters, return value, and raised exceptions.  
   - Add type hints for clarity and static analysis support.

8. **Final Code Structure**  
   - Combine the above steps into a single function block, ensuring no extraneous code or comments outside the function.  
   - The function meets all specified requirements and adheres to best practices (early return, input validation, clear documentation). <ANS_START>
```python
def binary_search(arr: list, target) -> int:
    """
    Perform binary search on a sorted list.

    Parameters
    ----------
    arr : list
        Sorted list to search.
    target : Any
        Value to locate.

    Returns
    -------
    int
        Index of target in arr, or -1 if not found.

    Raises
    ------
    ValueError
        If arr is not sorted.
    """
    if not arr:
        return -1

    # Verify sortedness
    if any(arr[i] > arr[i + 1] for i in range(len(arr) - 1)):
        raise ValueError("Input list must be sorted.")

    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```
<ANS_END>


At the end, wrap only your final option between <ANS_START> and <ANS_END> tags
Keywords: coding, best practices, documentation, version control, optimization