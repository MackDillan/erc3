{"question": "Implement a function to calculate the factorial of a non\u2011negative integer using memoization to improve performance. The function should raise a `ValueError` for negative inputs.", "answer": "1. Define a function `factorial(n)` that returns `n!`.  \n2. Validate that `n` is non\u2011negative; otherwise raise `ValueError`.  \n3. Use the base case `factorial(0) = 1`.  \n4. For `n > 0`, compute recursively: `n * factorial(n-1)`.  \n5. Decorate the function with `functools.lru_cache` to memoize results.  \n6. Return the computed value.\n\n<ANS_START>\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef factorial(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a non\u2011negative integer using memoization.\n\n    Parameters\n    ----------\n    n : int\n        Non\u2011negative integer whose factorial is to be computed.\n\n    Returns\n    -------\n    int\n        Factorial of n.\n\n    Raises\n    ------\n    ValueError\n        If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non\u2011negative integer.\")\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n```\n<ANS_END>", "final_answer": "\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef factorial(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a non\u2011negative integer using memoization.\n\n    Parameters\n    ----------\n    n : int\n        Non\u2011negative integer whose factorial is to be computed.\n\n    Returns\n    -------\n    int\n        Factorial of n.\n\n    Raises\n    ------\n    ValueError\n        If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non\u2011negative integer.\")\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n```\n"}
{"question": "Write a `BankAccount` class that supports deposit, withdrawal, and balance inquiry. The class should prevent overdrafts and include unit tests using `unittest`.", "answer": "1. Create `BankAccount` with an initial balance.  \n2. Implement `deposit(amount)` adding to balance.  \n3. Implement `withdraw(amount)` subtracting from balance; raise `ValueError` if insufficient funds.  \n4. Provide `balance` property.  \n5. Write unit tests covering normal operations and overdraft prevention.\n\n<ANS_START>\n```python\nclass BankAccount:\n    \"\"\"\n    Simple bank account model with deposit, withdrawal, and balance tracking.\n    \"\"\"\n\n    def __init__(self, initial_balance: float = 0.0):\n        if initial_balance < 0:\n            raise ValueError(\"Initial balance cannot be negative.\")\n        self._balance = float(initial_balance)\n\n    @property\n    def balance(self) -> float:\n        \"\"\"Return the current account balance.\"\"\"\n        return self._balance\n\n    def deposit(self, amount: float) -> None:\n        \"\"\"Deposit a positive amount into the account.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"Deposit amount must be positive.\")\n        self._balance += amount\n\n    def withdraw(self, amount: float) -> None:\n        \"\"\"Withdraw a positive amount from the account if sufficient funds exist.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive.\")\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds.\")\n        self._balance -= amount\n\n\n# Unit tests\nimport unittest\n\nclass TestBankAccount(unittest.TestCase):\n    def setUp(self):\n        self.account = BankAccount(100.0)\n\n    def test_deposit(self):\n        self.account.deposit(50)\n        self.assertEqual(self.account.balance, 150)\n\n    def test_withdraw(self):\n        self.account.withdraw(30)\n        self.assertEqual(self.account.balance, 70)\n\n    def test_overdraft(self):\n        with self.assertRaises(ValueError):\n            self.account.withdraw(200)\n\n    def test_negative_deposit(self):\n        with self.assertRaises(ValueError):\n            self.account.deposit(-10)\n\n    def test_negative_withdraw(self):\n        with self.assertRaises(ValueError):\n            self.account.withdraw(-5)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n<ANS_END>", "final_answer": "\n```python\nclass BankAccount:\n    \"\"\"\n    Simple bank account model with deposit, withdrawal, and balance tracking.\n    \"\"\"\n\n    def __init__(self, initial_balance: float = 0.0):\n        if initial_balance < 0:\n            raise ValueError(\"Initial balance cannot be negative.\")\n        self._balance = float(initial_balance)\n\n    @property\n    def balance(self) -> float:\n        \"\"\"Return the current account balance.\"\"\"\n        return self._balance\n\n    def deposit(self, amount: float) -> None:\n        \"\"\"Deposit a positive amount into the account.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"Deposit amount must be positive.\")\n        self._balance += amount\n\n    def withdraw(self, amount: float) -> None:\n        \"\"\"Withdraw a positive amount from the account if sufficient funds exist.\"\"\"\n        if amount <= 0:\n            raise ValueError(\"Withdrawal amount must be positive.\")\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds.\")\n        self._balance -= amount\n\n\n# Unit tests\nimport unittest\n\nclass TestBankAccount(unittest.TestCase):\n    def setUp(self):\n        self.account = BankAccount(100.0)\n\n    def test_deposit(self):\n        self.account.deposit(50)\n        self.assertEqual(self.account.balance, 150)\n\n    def test_withdraw(self):\n        self.account.withdraw(30)\n        self.assertEqual(self.account.balance, 70)\n\n    def test_overdraft(self):\n        with self.assertRaises(ValueError):\n            self.account.withdraw(200)\n\n    def test_negative_deposit(self):\n        with self.assertRaises(ValueError):\n            self.account.deposit(-10)\n\n    def test_negative_withdraw(self):\n        with self.assertRaises(ValueError):\n            self.account.withdraw(-5)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n"}
{"question": "Create a Flask REST API endpoint `/items` that returns a JSON list of items. Include proper error handling and input validation for query parameters `limit` and `offset`.", "answer": "1. Set up a Flask app and define `/items` route.  \n2. Accept optional `limit` and `offset` query params; default to 10 and 0.  \n3. Validate that `limit` and `offset` are integers \u2265 0; otherwise return 400.  \n4. Retrieve items from a mock data source and slice according to pagination.  \n5. Return JSON response with status 200.  \n6. Wrap route in try/except to catch unexpected errors and return 500.\n\n<ANS_START>\n```python\nfrom flask import Flask, request, jsonify, abort\nfrom typing import List, Dict\n\napp = Flask(__name__)\n\n# Mock data source\nITEMS: List[Dict[str, str]] = [\n    {\"id\": i, \"name\": f\"Item {i}\"} for i in range(1, 101)\n]\n\ndef validate_int_param(value: str, name: str, default: int) -> int:\n    if value is None:\n        return default\n    try:\n        val = int(value)\n        if val < 0:\n            raise ValueError\n        return val\n    except ValueError:\n        abort(400, description=f\"Invalid {name} parameter; must be a non\u2011negative integer.\")\n\n@app.route(\"/items\", methods=[\"GET\"])\ndef get_items():\n    try:\n        limit = validate_int_param(request.args.get(\"limit\"), \"limit\", 10)\n        offset = validate_int_param(request.args.get(\"offset\"), \"offset\", 0)\n        sliced = ITEMS[offset : offset + limit]\n        return jsonify({\"items\": sliced, \"count\": len(sliced)}), 200\n    except Exception as e:\n        # Log the exception in a real application\n        abort(500, description=\"Internal server error.\")\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n```\n<ANS_END>", "final_answer": "\n```python\nfrom flask import Flask, request, jsonify, abort\nfrom typing import List, Dict\n\napp = Flask(__name__)\n\n# Mock data source\nITEMS: List[Dict[str, str]] = [\n    {\"id\": i, \"name\": f\"Item {i}\"} for i in range(1, 101)\n]\n\ndef validate_int_param(value: str, name: str, default: int) -> int:\n    if value is None:\n        return default\n    try:\n        val = int(value)\n        if val < 0:\n            raise ValueError\n        return val\n    except ValueError:\n        abort(400, description=f\"Invalid {name} parameter; must be a non\u2011negative integer.\")\n\n@app.route(\"/items\", methods=[\"GET\"])\ndef get_items():\n    try:\n        limit = validate_int_param(request.args.get(\"limit\"), \"limit\", 10)\n        offset = validate_int_param(request.args.get(\"offset\"), \"offset\", 0)\n        sliced = ITEMS[offset : offset + limit]\n        return jsonify({\"items\": sliced, \"count\": len(sliced)}), 200\n    except Exception as e:\n        # Log the exception in a real application\n        abort(500, description=\"Internal server error.\")\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n```\n"}
{"question": "Write a Python script that reads a CSV file `data.csv`, converts each row to a dictionary, and writes the result to `data.json`. Include logging to track progress and handle missing files gracefully.", "answer": "1. Import `csv`, `json`, `logging`, and `pathlib`.  \n2. Configure logging to output to console.  \n3. Define `csv_to_json(csv_path, json_path)`.  \n4. Check if CSV exists; if not, log error and exit.  \n5. Read CSV with `csv.DictReader`.  \n6. Convert rows to list of dicts.  \n7. Write list to JSON file with indentation.  \n8. Log success message.\n\n<ANS_START>\n```python\nimport csv\nimport json\nimport logging\nfrom pathlib import Path\nimport sys\n\nlogging.basicConfig(level=logging.INFO, format=\"%(levelname)s: %(message)s\")\n\ndef csv_to_json(csv_path: str, json_path: str) -> None:\n    csv_file = Path(csv_path)\n    json_file = Path(json_path)\n\n    if not csv_file.is_file():\n        logging.error(f\"CSV file not found: {csv_path}\")\n        sys.exit(1)\n\n    try:\n        with csv_file.open(newline=\"\", encoding=\"utf-8\") as f:\n            reader = csv.DictReader(f)\n            rows = list(reader)\n        logging.info(f\"Read {len(rows)} rows from {csv_path}\")\n\n        with json_file.open(\"w\", encoding=\"utf-8\") as f:\n            json.dump(rows, f, indent=4)\n        logging.info(f\"Wrote JSON to {json_path}\")\n    except Exception as exc:\n        logging.exception(\"An error occurred during conversion.\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    csv_to_json(\"data.csv\", \"data.json\")\n```\n<ANS_END>", "final_answer": "\n```python\nimport csv\nimport json\nimport logging\nfrom pathlib import Path\nimport sys\n\nlogging.basicConfig(level=logging.INFO, format=\"%(levelname)s: %(message)s\")\n\ndef csv_to_json(csv_path: str, json_path: str) -> None:\n    csv_file = Path(csv_path)\n    json_file = Path(json_path)\n\n    if not csv_file.is_file():\n        logging.error(f\"CSV file not found: {csv_path}\")\n        sys.exit(1)\n\n    try:\n        with csv_file.open(newline=\"\", encoding=\"utf-8\") as f:\n            reader = csv.DictReader(f)\n            rows = list(reader)\n        logging.info(f\"Read {len(rows)} rows from {csv_path}\")\n\n        with json_file.open(\"w\", encoding=\"utf-8\") as f:\n            json.dump(rows, f, indent=4)\n        logging.info(f\"Wrote JSON to {json_path}\")\n    except Exception as exc:\n        logging.exception(\"An error occurred during conversion.\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    csv_to_json(\"data.csv\", \"data.json\")\n```\n"}
{"question": "Implement a binary search function `binary_search(arr, target)` that returns the index of `target` in a sorted list `arr` or `-1` if not found. Include edge\u2011case handling for empty lists and non\u2011sorted input.", "answer": "1. Validate that `arr` is a list; if empty return -1.  \n2. Check if `arr` is sorted; if not, raise `ValueError`.  \n3. Use iterative binary search: maintain `low` and `high`.  \n4. Compare middle element to target; adjust bounds accordingly.  \n5. Return index if found; else -1.\n\n<ANS_START>\n```python\ndef binary_search(arr: list, target) -> int:\n    \"\"\"\n    Perform binary search on a sorted list.\n\n    Parameters\n    ----------\n    arr : list\n        Sorted list to search.\n    target : Any\n        Value to locate.\n\n    Returns\n    -------\n    int\n        Index of target in arr, or -1 if not found.\n\n    Raises\n    ------\n    ValueError\n        If arr is not sorted.\n    \"\"\"\n    if not arr:\n        return -1\n\n    # Verify sortedness\n    if any(arr[i] > arr[i + 1] for i in range(len(arr) - 1)):\n        raise ValueError(\"Input list must be sorted.\")\n\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n```\n<ANS_END>", "final_answer": "\n```python\ndef binary_search(arr: list, target) -> int:\n    \"\"\"\n    Perform binary search on a sorted list.\n\n    Parameters\n    ----------\n    arr : list\n        Sorted list to search.\n    target : Any\n        Value to locate.\n\n    Returns\n    -------\n    int\n        Index of target in arr, or -1 if not found.\n\n    Raises\n    ------\n    ValueError\n        If arr is not sorted.\n    \"\"\"\n    if not arr:\n        return -1\n\n    # Verify sortedness\n    if any(arr[i] > arr[i + 1] for i in range(len(arr) - 1)):\n        raise ValueError(\"Input list must be sorted.\")\n\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n```\n"}
{"question": "Write a decorator `timed` that measures and prints the execution time of the decorated function. The decorator should preserve the original function\u2019s metadata.", "answer": "1. Import `time` and `functools.wraps`.  \n2. Define `timed(func)` returning wrapper.  \n3. In wrapper, record start time, call function, record end time.  \n4. Compute elapsed time and print.  \n5. Return function result.  \n6. Use `@wraps(func)` to preserve metadata.\n\n<ANS_START>\n```python\nimport time\nfrom functools import wraps\n\ndef timed(func):\n    \"\"\"\n    Decorator that prints the execution time of the decorated function.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n        print(f\"{func.__name__} executed in {end - start:.6f}s\")\n        return result\n    return wrapper\n```\n<ANS_END>", "final_answer": "\n```python\nimport time\nfrom functools import wraps\n\ndef timed(func):\n    \"\"\"\n    Decorator that prints the execution time of the decorated function.\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n        print(f\"{func.__name__} executed in {end - start:.6f}s\")\n        return result\n    return wrapper\n```\n"}
{"question": "Implement a context manager `suppress_exceptions` that suppresses specified exception types and optionally logs them. Use it to safely open a file that might not exist.", "answer": "1. Define class `suppress_exceptions(*exc_types, log=False)`.  \n2. In `__enter__`, do nothing.  \n3. In `__exit__`, if exception type matches, optionally log, then return True to suppress.  \n4. Demonstrate usage with `open(\"missing.txt\")`.\n\n<ANS_START>\n```python\nimport logging\nfrom contextlib import ContextDecorator\n\nclass suppress_exceptions(ContextDecorator):\n    \"\"\"\n    Context manager that suppresses specified exception types.\n    \"\"\"\n    def __init__(self, *exc_types, log: bool = False):\n        self.exc_types = exc_types\n        self.log = log\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is None:\n            return False\n        if issubclass(exc_type, self.exc_types):\n            if self.log:\n                logging.exception(\"Suppressed exception\", exc_info=(exc_type, exc_val, exc_tb))\n            return True  # Suppress\n        return False  # Propagate other exceptions\n\n# Example usage\nwith suppress_exceptions(FileNotFoundError, log=True):\n    with open(\"missing.txt\") as f:\n        data = f.read()\nprint(\"Continuing after suppressed exception.\")\n```\n<ANS_END>", "final_answer": "\n```python\nimport logging\nfrom contextlib import ContextDecorator\n\nclass suppress_exceptions(ContextDecorator):\n    \"\"\"\n    Context manager that suppresses specified exception types.\n    \"\"\"\n    def __init__(self, *exc_types, log: bool = False):\n        self.exc_types = exc_types\n        self.log = log\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is None:\n            return False\n        if issubclass(exc_type, self.exc_types):\n            if self.log:\n                logging.exception(\"Suppressed exception\", exc_info=(exc_type, exc_val, exc_tb))\n            return True  # Suppress\n        return False  # Propagate other exceptions\n\n# Example usage\nwith suppress_exceptions(FileNotFoundError, log=True):\n    with open(\"missing.txt\") as f:\n        data = f.read()\nprint(\"Continuing after suppressed exception.\")\n```\n"}
{"question": "Create a thread\u2011safe singleton class `Config` that loads configuration from a JSON file once and provides read\u2011only access to its values.", "answer": "1. Use a class variable `_instance` and a lock.  \n2. In `__new__`, acquire lock, create instance if not exists.  \n3. Load JSON in `__init__` only once.  \n4. Provide `get(key)` method.  \n5. Ensure immutability by not exposing internal dict.\n\n<ANS_START>\n```python\nimport json\nimport threading\nfrom pathlib import Path\n\nclass Config:\n    _instance = None\n    _lock = threading.Lock()\n\n    def __new__(cls, config_path: str = \"config.json\"):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(Config, cls).__new__(cls)\n                    cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self, config_path: str = \"config.json\"):\n        if self._initialized:\n            return\n        self._config_path = Path(config_path)\n        if not self._config_path.is_file():\n            raise FileNotFoundError(f\"Config file not found: {config_path}\")\n        with self._config_path.open(encoding=\"utf-8\") as f:\n            self._data = json.load(f)\n        self._initialized = True\n\n    def get(self, key: str, default=None):\n        return self._data.get(key, default)\n\n    def __repr__(self):\n        return f\"<Config loaded from {self._config_path}>\"\n```\n<ANS_END>", "final_answer": "\n```python\nimport json\nimport threading\nfrom pathlib import Path\n\nclass Config:\n    _instance = None\n    _lock = threading.Lock()\n\n    def __new__(cls, config_path: str = \"config.json\"):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(Config, cls).__new__(cls)\n                    cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self, config_path: str = \"config.json\"):\n        if self._initialized:\n            return\n        self._config_path = Path(config_path)\n        if not self._config_path.is_file():\n            raise FileNotFoundError(f\"Config file not found: {config_path}\")\n        with self._config_path.open(encoding=\"utf-8\") as f:\n            self._data = json.load(f)\n        self._initialized = True\n\n    def get(self, key: str, default=None):\n        return self._data.get(key, default)\n\n    def __repr__(self):\n        return f\"<Config loaded from {self._config_path}>\"\n```\n"}
{"question": "Write a function `sort_dicts_by_key(dicts, key, reverse=False)` that sorts a list of dictionaries by a specified key, handling missing keys by treating them as `None`.", "answer": "1. Define function accepting list of dicts, key, reverse flag.  \n2. Use `sorted` with key function that returns tuple `(dict.get(key) is None, dict.get(key))` to push missing keys to end.  \n3. Return sorted list.\n\n<ANS_START>\n```python\ndef sort_dicts_by_key(dicts: list, key: str, reverse: bool = False) -> list:\n    \"\"\"\n    Sort a list of dictionaries by a specified key.\n\n    Parameters\n    ----------\n    dicts : list\n        List of dictionaries to sort.\n    key : str\n        Key to sort by.\n    reverse : bool, optional\n        Sort in descending order if True.\n\n    Returns\n    -------\n    list\n        Sorted list of dictionaries.\n    \"\"\"\n    return sorted(\n        dicts,\n        key=lambda d: (d.get(key) is None, d.get(key)),\n        reverse=reverse\n    )\n```\n<ANS_END>", "final_answer": "\n```python\ndef sort_dicts_by_key(dicts: list, key: str, reverse: bool = False) -> list:\n    \"\"\"\n    Sort a list of dictionaries by a specified key.\n\n    Parameters\n    ----------\n    dicts : list\n        List of dictionaries to sort.\n    key : str\n        Key to sort by.\n    reverse : bool, optional\n        Sort in descending order if True.\n\n    Returns\n    -------\n    list\n        Sorted list of dictionaries.\n    \"\"\"\n    return sorted(\n        dicts,\n        key=lambda d: (d.get(key) is None, d.get(key)),\n        reverse=reverse\n    )\n```\n"}
{"question": "Build a command\u2011line interface (CLI) using `argparse` that supports subcommands `add` and `subtract`. Each subcommand takes two integers and prints the result.", "answer": "1. Create `ArgumentParser`.  \n2. Add subparsers for `add` and `subtract`.  \n3. Each subparser defines two positional int arguments.  \n4. Parse args and perform operation.  \n5. Print result.\n\n<ANS_START>\n```python\nimport argparse\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple calculator CLI.\")\n    subparsers = parser.add_subparsers(dest=\"command\", required=True)\n\n    # Add subcommand\n    parser_add = subparsers.add_parser(\"add\", help=\"Add two numbers.\")\n    parser_add.add_argument(\"x\", type=int, help=\"First integer.\")\n    parser_add.add_argument(\"y\", type=int, help=\"Second integer.\")\n\n    # Subtract subcommand\n    parser_sub = subparsers.add_parser(\"subtract\", help=\"Subtract two numbers.\")\n    parser_sub.add_argument(\"x\", type=int, help=\"First integer.\")\n    parser_sub.add_argument(\"y\", type=int, help=\"Second integer.\")\n\n    args = parser.parse_args()\n\n    if args.command == \"add\":\n        result = args.x + args.y\n    elif args.command == \"subtract\":\n        result = args.x - args.y\n    else:\n        parser.error(\"Unknown command\")\n\n    print(f\"Result: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n<ANS_END>", "final_answer": "\n```python\nimport argparse\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple calculator CLI.\")\n    subparsers = parser.add_subparsers(dest=\"command\", required=True)\n\n    # Add subcommand\n    parser_add = subparsers.add_parser(\"add\", help=\"Add two numbers.\")\n    parser_add.add_argument(\"x\", type=int, help=\"First integer.\")\n    parser_add.add_argument(\"y\", type=int, help=\"Second integer.\")\n\n    # Subtract subcommand\n    parser_sub = subparsers.add_parser(\"subtract\", help=\"Subtract two numbers.\")\n    parser_sub.add_argument(\"x\", type=int, help=\"First integer.\")\n    parser_sub.add_argument(\"y\", type=int, help=\"Second integer.\")\n\n    args = parser.parse_args()\n\n    if args.command == \"add\":\n        result = args.x + args.y\n    elif args.command == \"subtract\":\n        result = args.x - args.y\n    else:\n        parser.error(\"Unknown command\")\n\n    print(f\"Result: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n"}
{"question": "Implement a function `is_valid_email(email)` that validates an email address using a regular expression. The function should return `True` for valid addresses and `False` otherwise.", "answer": "1. Import `re`.  \n2. Compile a regex pattern that matches typical email formats.  \n3. Use `fullmatch` to validate.  \n4. Return boolean.\n\n<ANS_START>\n```python\nimport re\n\n_email_regex = re.compile(\n    r\"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$\"\n)\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Validate an email address using a regular expression.\n\n    Parameters\n    ----------\n    email : str\n        Email address to validate.\n\n    Returns\n    -------\n    bool\n        True if email is valid, False otherwise.\n    \"\"\"\n    return bool(_email_regex.fullmatch(email))\n```\n<ANS_END>", "final_answer": "\n```python\nimport re\n\n_email_regex = re.compile(\n    r\"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$\"\n)\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Validate an email address using a regular expression.\n\n    Parameters\n    ----------\n    email : str\n        Email address to validate.\n\n    Returns\n    -------\n    bool\n        True if email is valid, False otherwise.\n    \"\"\"\n    return bool(_email_regex.fullmatch(email))\n```\n"}
{"question": "Create a simple caching decorator using `functools.lru_cache` that caches the results of a function computing the nth Fibonacci number. Include a unit test verifying cache hits.", "answer": "1. Define `fib(n)` with recursion.  \n2. Decorate with `@lru_cache(maxsize=None)`.  \n3. Write test that calls `fib(30)` twice and checks that the second call is faster or that cache info shows hits.\n\n<ANS_START>\n```python\nfrom functools import lru_cache\nimport time\nimport unittest\n\n@lru_cache(maxsize=None)\ndef fib(n: int) -> int:\n    \"\"\"Compute the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nclass TestFibCache(unittest.TestCase):\n    def test_cache_hits(self):\n        start = time.perf_counter()\n        first = fib(30)\n        first_time = time.perf_counter() - start\n\n        start = time.perf_counter()\n        second = fib(30)\n        second_time = time.perf_counter() - start\n\n        self.assertEqual(first, second)\n        self.assertLess(second_time, first_time * 0.1)  # second call should be much faster\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n<ANS_END>", "final_answer": "\n```python\nfrom functools import lru_cache\nimport time\nimport unittest\n\n@lru_cache(maxsize=None)\ndef fib(n: int) -> int:\n    \"\"\"Compute the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nclass TestFibCache(unittest.TestCase):\n    def test_cache_hits(self):\n        start = time.perf_counter()\n        first = fib(30)\n        first_time = time.perf_counter() - start\n\n        start = time.perf_counter()\n        second = fib(30)\n        second_time = time.perf_counter() - start\n\n        self.assertEqual(first, second)\n        self.assertLess(second_time, first_time * 0.1)  # second call should be much faster\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n"}
{"question": "Write a unit test for a function `fibonacci(n)` that returns the nth Fibonacci number. The test should cover typical cases, edge cases, and invalid input.", "answer": "1. Import `unittest`.  \n2. Define test cases: `n=0,1,5,10`.  \n3. Test negative input raises `ValueError`.  \n4. Use `assertEqual` and `assertRaises`.\n\n<ANS_START>\n```python\nimport unittest\n\ndef fibonacci(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non\u2011negative\")\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nclass TestFibonacci(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(fibonacci(0), 0)\n        self.assertEqual(fibonacci(1), 1)\n        self.assertEqual(fibonacci(5), 5)\n        self.assertEqual(fibonacci(10), 55)\n\n    def test_negative(self):\n        with self.assertRaises(ValueError):\n            fibonacci(-3)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n<ANS_END>", "final_answer": "\n```python\nimport unittest\n\ndef fibonacci(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non\u2011negative\")\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nclass TestFibonacci(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(fibonacci(0), 0)\n        self.assertEqual(fibonacci(1), 1)\n        self.assertEqual(fibonacci(5), 5)\n        self.assertEqual(fibonacci(10), 55)\n\n    def test_negative(self):\n        with self.assertRaises(ValueError):\n            fibonacci(-3)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n"}
{"question": "Implement a function `get_env_var(name, default=None)` that reads an environment variable and returns its value or a default if not set. The function should raise an error if the variable is required but missing.", "answer": "1. Import `os`.  \n2. Define function with `required` flag.  \n3. Use `os.getenv`.  \n4. If required and missing, raise `KeyError`.  \n5. Return value or default.\n\n<ANS_START>\n```python\nimport os\n\ndef get_env_var(name: str, default=None, required: bool = False):\n    \"\"\"\n    Retrieve an environment variable.\n\n    Parameters\n    ----------\n    name : str\n        Name of the environment variable.\n    default : Any, optional\n        Value to return if variable is not set.\n    required : bool, optional\n        If True, raise KeyError when variable is missing.\n\n    Returns\n    -------\n    Any\n        The environment variable's value or the default.\n\n    Raises\n    ------\n    KeyError\n        If required is True and the variable is missing.\n    \"\"\"\n    value = os.getenv(name)\n    if value is None:\n        if required:\n            raise KeyError(f\"Required environment variable '{name}' not set.\")\n        return default\n    return value\n```\n<ANS_END>", "final_answer": "\n```python\nimport os\n\ndef get_env_var(name: str, default=None, required: bool = False):\n    \"\"\"\n    Retrieve an environment variable.\n\n    Parameters\n    ----------\n    name : str\n        Name of the environment variable.\n    default : Any, optional\n        Value to return if variable is not set.\n    required : bool, optional\n        If True, raise KeyError when variable is missing.\n\n    Returns\n    -------\n    Any\n        The environment variable's value or the default.\n\n    Raises\n    ------\n    KeyError\n        If required is True and the variable is missing.\n    \"\"\"\n    value = os.getenv(name)\n    if value is None:\n        if required:\n            raise KeyError(f\"Required environment variable '{name}' not set.\")\n        return default\n    return value\n```\n"}
{"question": "Create a logger that writes messages to both console and a file named `app.log`. The logger should include timestamps and log level in each message.", "answer": "1. Import `logging`.  \n2. Create `logging.getLogger(\"app\")`.  \n3. Set level to `DEBUG`.  \n4. Add `StreamHandler` and `FileHandler`.  \n5. Define formatter with timestamp and level.  \n6. Attach formatter to handlers.\n\n<ANS_START>\n```python\nimport logging\n\ndef setup_logger(name: str = \"app\") -> logging.Logger:\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n    if logger.handlers:\n        return logger  # Avoid duplicate handlers\n\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n\n    # Console handler\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\n    # File handler\n    fh = logging.FileHandler(\"app.log\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(formatter)\n    logger.addHandler(fh)\n\n    return logger\n\n# Example usage\nif __name__ == \"__main__\":\n    log = setup_logger()\n    log.debug(\"Debug message\")\n    log.info(\"Info message\")\n    log.warning(\"Warning message\")\n```\n<ANS_END>", "final_answer": "\n```python\nimport logging\n\ndef setup_logger(name: str = \"app\") -> logging.Logger:\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n    if logger.handlers:\n        return logger  # Avoid duplicate handlers\n\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n\n    # Console handler\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\n    # File handler\n    fh = logging.FileHandler(\"app.log\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(formatter)\n    logger.addHandler(fh)\n\n    return logger\n\n# Example usage\nif __name__ == \"__main__\":\n    log = setup_logger()\n    log.debug(\"Debug message\")\n    log.info(\"Info message\")\n    log.warning(\"Warning message\")\n```\n"}
{"question": "Implement an in\u2011memory key\u2011value store `Cache` with expiration support. Keys should expire after a specified TTL (time\u2011to\u2011live) in seconds.", "answer": "1. Use a dict to store values and expiration timestamps.  \n2. Provide `set(key, value, ttl)` and `get(key)`.  \n3. In `get`, check if current time > expiration; if so, delete and return None.  \n4. Use `time.time()` for timestamps.\n\n<ANS_START>\n```python\nimport time\nfrom typing import Any, Dict, Tuple\n\nclass Cache:\n    \"\"\"\n    Simple in\u2011memory key\u2011value store with TTL support.\n    \"\"\"\n\n    def __init__(self):\n        self._store: Dict[Any, Tuple[Any, float]] = {}\n\n    def set(self, key: Any, value: Any, ttl: float) -> None:\n        \"\"\"\n        Store a value with a time\u2011to\u2011live (TTL).\n\n        Parameters\n        ----------\n        key : Any\n            Key under which to store the value.\n        value : Any\n            Value to store.\n        ttl : float\n            Time\u2011to\u2011live in seconds.\n        \"\"\"\n        expire_at = time.time() + ttl\n        self._store[key] = (value, expire_at)\n\n    def get(self, key: Any) -> Any:\n        \"\"\"\n        Retrieve a value if it hasn't expired; otherwise return None.\n\n        Parameters\n        ----------\n        key : Any\n            Key to retrieve.\n\n        Returns\n        -------\n        Any\n            Stored value or None if missing/expired.\n        \"\"\"\n        entry = self._store.get(key)\n        if entry is None:\n            return None\n        value, expire_at = entry\n        if time.time() > expire_at:\n            del self._store[key]\n            return None\n        return value\n\n    def __contains__(self, key: Any) -> bool:\n        return self.get(key) is not None\n```\n<ANS_END>", "final_answer": "\n```python\nimport time\nfrom typing import Any, Dict, Tuple\n\nclass Cache:\n    \"\"\"\n    Simple in\u2011memory key\u2011value store with TTL support.\n    \"\"\"\n\n    def __init__(self):\n        self._store: Dict[Any, Tuple[Any, float]] = {}\n\n    def set(self, key: Any, value: Any, ttl: float) -> None:\n        \"\"\"\n        Store a value with a time\u2011to\u2011live (TTL).\n\n        Parameters\n        ----------\n        key : Any\n            Key under which to store the value.\n        value : Any\n            Value to store.\n        ttl : float\n            Time\u2011to\u2011live in seconds.\n        \"\"\"\n        expire_at = time.time() + ttl\n        self._store[key] = (value, expire_at)\n\n    def get(self, key: Any) -> Any:\n        \"\"\"\n        Retrieve a value if it hasn't expired; otherwise return None.\n\n        Parameters\n        ----------\n        key : Any\n            Key to retrieve.\n\n        Returns\n        -------\n        Any\n            Stored value or None if missing/expired.\n        \"\"\"\n        entry = self._store.get(key)\n        if entry is None:\n            return None\n        value, expire_at = entry\n        if time.time() > expire_at:\n            del self._store[key]\n            return None\n        return value\n\n    def __contains__(self, key: Any) -> bool:\n        return self.get(key) is not None\n```\n"}
{"question": "Write a function `http_get(url, retries=3, backoff=1)` that performs an HTTP GET request with retry logic. Use `requests` and raise an exception if all retries fail.", "answer": "1. Import `requests` and `time`.  \n2. Loop up to `retries`.  \n3. Try `requests.get(url, timeout=5)`.  \n4. On exception, sleep `backoff * attempt`.  \n5. If success, return response.  \n6. After loop, raise `RuntimeError`.\n\n<ANS_START>\n```python\nimport requests\nimport time\nfrom typing import Optional\n\ndef http_get(url: str, retries: int = 3, backoff: float = 1.0) -> requests.Response:\n    \"\"\"\n    Perform an HTTP GET request with retry logic.\n\n    Parameters\n    ----------\n    url : str\n        Target URL.\n    retries : int, optional\n        Number of retry attempts.\n    backoff : float, optional\n        Seconds to wait before each retry.\n\n    Returns\n    -------\n    requests.Response\n        Successful HTTP response.\n\n    Raises\n    ------\n    RuntimeError\n        If all retry attempts fail.\n    \"\"\"\n    for attempt in range(1, retries + 1):\n        try:\n            response = requests.get(url, timeout=5)\n            response.raise_for_status()\n            return response\n        except requests.RequestException as exc:\n            if attempt == retries:\n                raise RuntimeError(f\"GET {url} failed after {retries} attempts\") from exc\n            time.sleep(backoff * attempt)\n```\n<ANS_END>", "final_answer": "\n```python\nimport requests\nimport time\nfrom typing import Optional\n\ndef http_get(url: str, retries: int = 3, backoff: float = 1.0) -> requests.Response:\n    \"\"\"\n    Perform an HTTP GET request with retry logic.\n\n    Parameters\n    ----------\n    url : str\n        Target URL.\n    retries : int, optional\n        Number of retry attempts.\n    backoff : float, optional\n        Seconds to wait before each retry.\n\n    Returns\n    -------\n    requests.Response\n        Successful HTTP response.\n\n    Raises\n    ------\n    RuntimeError\n        If all retry attempts fail.\n    \"\"\"\n    for attempt in range(1, retries + 1):\n        try:\n            response = requests.get(url, timeout=5)\n            response.raise_for_status()\n            return response\n        except requests.RequestException as exc:\n            if attempt == retries:\n                raise RuntimeError(f\"GET {url} failed after {retries} attempts\") from exc\n            time.sleep(backoff * attempt)\n```\n"}
{"question": "Implement a function `format_iso_date(date_str)` that converts a date string in `YYYY-MM-DD` format to ISO 8601 format with time `00:00:00Z`. Validate input format and raise `ValueError` if invalid.", "answer": "1. Import `datetime`.  \n2. Parse with `strptime`.  \n3. Format with `isoformat()` and append `Z`.  \n4. Handle parsing errors.\n\n<ANS_START>\n```python\nfrom datetime import datetime\n\ndef format_iso_date(date_str: str) -> str:\n    \"\"\"\n    Convert a YYYY\u2011MM\u2011DD date string to ISO 8601 format with UTC time.\n\n    Parameters\n    ----------\n    date_str : str\n        Date string in 'YYYY-MM-DD' format.\n\n    Returns\n    -------\n    str\n        ISO 8601 formatted date string, e.g., '2023-12-31T00:00:00Z'.\n\n    Raises\n    ------\n    ValueError\n        If input is not in the expected format.\n    \"\"\"\n    try:\n        dt = datetime.strptime(date_str, \"%Y-%m-%d\")\n    except ValueError as exc:\n        raise ValueError(f\"Invalid date format: {date_str}\") from exc\n    return dt.isoformat(timespec=\"seconds\") + \"Z\"\n```\n<ANS_END>", "final_answer": "\n```python\nfrom datetime import datetime\n\ndef format_iso_date(date_str: str) -> str:\n    \"\"\"\n    Convert a YYYY\u2011MM\u2011DD date string to ISO 8601 format with UTC time.\n\n    Parameters\n    ----------\n    date_str : str\n        Date string in 'YYYY-MM-DD' format.\n\n    Returns\n    -------\n    str\n        ISO 8601 formatted date string, e.g., '2023-12-31T00:00:00Z'.\n\n    Raises\n    ------\n    ValueError\n        If input is not in the expected format.\n    \"\"\"\n    try:\n        dt = datetime.strptime(date_str, \"%Y-%m-%d\")\n    except ValueError as exc:\n        raise ValueError(f\"Invalid date format: {date_str}\") from exc\n    return dt.isoformat(timespec=\"seconds\") + \"Z\"\n```\n"}
{"question": "Write a function `deep_merge(dict1, dict2)` that recursively merges two dictionaries. Values from `dict2` should overwrite those in `dict1` when keys collide.", "answer": "1. Iterate over `dict2` items.  \n2. If key exists in both and both values are dicts, recurse.  \n3. Else, set value from `dict2`.  \n4. Return merged dict.\n\n<ANS_START>\n```python\nfrom typing import Any, Dict\n\ndef deep_merge(dict1: Dict[Any, Any], dict2: Dict[Any, Any]) -> Dict[Any, Any]:\n    \"\"\"\n    Recursively merge dict2 into dict1.\n\n    Parameters\n    ----------\n    dict1 : dict\n        Base dictionary.\n    dict2 : dict\n        Dictionary to merge into dict1.\n\n    Returns\n    -------\n    dict\n        Merged dictionary.\n    \"\"\"\n    result = dict1.copy()\n    for key, value in dict2.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        else:\n            result[key] = value\n    return result\n```\n<ANS_END>", "final_answer": "\n```python\nfrom typing import Any, Dict\n\ndef deep_merge(dict1: Dict[Any, Any], dict2: Dict[Any, Any]) -> Dict[Any, Any]:\n    \"\"\"\n    Recursively merge dict2 into dict1.\n\n    Parameters\n    ----------\n    dict1 : dict\n        Base dictionary.\n    dict2 : dict\n        Dictionary to merge into dict1.\n\n    Returns\n    -------\n    dict\n        Merged dictionary.\n    \"\"\"\n    result = dict1.copy()\n    for key, value in dict2.items():\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = deep_merge(result[key], value)\n        else:\n            result[key] = value\n    return result\n```\n"}
{"question": "Implement a simple observer pattern with a `Subject` class that can register observers and notify them with a payload. Observers are callables that accept the payload.", "answer": "1. Define `Subject` with `_observers` list.  \n2. Methods `register`, `unregister`, `notify`.  \n3. In `notify`, iterate observers and call with payload.\n\n<ANS_START>\n```python\nfrom typing import Callable, List, Any\n\nclass Subject:\n    \"\"\"\n    Basic observer pattern implementation.\n    \"\"\"\n\n    def __init__(self):\n        self._observers: List[Callable[[Any], None]] = []\n\n    def register(self, observer: Callable[[Any], None]) -> None:\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def unregister(self, observer: Callable[[Any], None]) -> None:\n        if observer in self._observers:\n            self._observers.remove(observer)\n\n    def notify(self, payload: Any) -> None:\n        for observer in list(self._observers):\n            observer(payload)\n```\n<ANS_END>", "final_answer": "\n```python\nfrom typing import Callable, List, Any\n\nclass Subject:\n    \"\"\"\n    Basic observer pattern implementation.\n    \"\"\"\n\n    def __init__(self):\n        self._observers: List[Callable[[Any], None]] = []\n\n    def register(self, observer: Callable[[Any], None]) -> None:\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def unregister(self, observer: Callable[[Any], None]) -> None:\n        if observer in self._observers:\n            self._observers.remove(observer)\n\n    def notify(self, payload: Any) -> None:\n        for observer in list(self._observers):\n            observer(payload)\n```\n"}
{"question": "Write a function `nth_prime(n)` that returns the nth prime number (1-indexed). Include a simple caching mechanism to speed up repeated calls.", "answer": "1. Use a list to store found primes.  \n2. Generate primes incrementally until reaching nth.  \n3. Cache primes in a global list.  \n4. Return nth element.\n\n<ANS_START>\n```python\nfrom typing import List\n\n_primes_cache: List[int] = []\n\ndef _is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for p in _primes_cache:\n        if p * p > num:\n            break\n        if num % p == 0:\n            return False\n    return True\n\ndef nth_prime(n: int) -> int:\n    \"\"\"\n    Return the nth prime number (1-indexed).\n\n    Parameters\n    ----------\n    n : int\n        Position of the prime to retrieve.\n\n    Returns\n    -------\n    int\n        The nth prime number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive.\")\n    while len(_primes_cache) < n:\n        candidate = _primes_cache[-1] + 1 if _primes_cache else 2\n        while not _is_prime(candidate):\n            candidate += 1\n        _primes_cache.append(candidate)\n    return _primes_cache[n - 1]\n```\n<ANS_END>", "final_answer": "\n```python\nfrom typing import List\n\n_primes_cache: List[int] = []\n\ndef _is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for p in _primes_cache:\n        if p * p > num:\n            break\n        if num % p == 0:\n            return False\n    return True\n\ndef nth_prime(n: int) -> int:\n    \"\"\"\n    Return the nth prime number (1-indexed).\n\n    Parameters\n    ----------\n    n : int\n        Position of the prime to retrieve.\n\n    Returns\n    -------\n    int\n        The nth prime number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be positive.\")\n    while len(_primes_cache) < n:\n        candidate = _primes_cache[-1] + 1 if _primes_cache else 2\n        while not _is_prime(candidate):\n            candidate += 1\n        _primes_cache.append(candidate)\n    return _primes_cache[n - 1]\n```\n"}
{"question": "Create a function `generate_password(length=12, uppercase=True, lowercase=True, digits=True, symbols=True)` that returns a random password meeting the specified criteria. Ensure at least one character from each selected category.", "answer": "1. Define character sets.  \n2. Build pool based on flags.  \n3. Ensure at least one from each selected set.  \n4. Fill remaining length with random choices from pool.  \n5. Shuffle and join.\n\n<ANS_START>\n```python\nimport random\nimport string\nfrom typing import List\n\ndef generate_password(\n    length: int = 12,\n    uppercase: bool = True,\n    lowercase: bool = True,\n    digits: bool = True,\n    symbols: bool = True,\n) -> str:\n    \"\"\"\n    Generate a random password satisfying the given constraints.\n\n    Parameters\n    ----------\n    length : int\n        Desired password length.\n    uppercase : bool\n        Include uppercase letters.\n    lowercase : bool\n        Include lowercase letters.\n    digits : bool\n        Include digits.\n    symbols : bool\n        Include punctuation symbols.\n\n    Returns\n    -------\n    str\n        Generated password.\n\n    Raises\n    ------\n    ValueError\n        If no character categories are selected or length is too short.\n    \"\"\"\n    if not any([uppercase, lowercase, digits, symbols]):\n        raise ValueError(\"At least one character type must be selected.\")\n    if length < 1:\n        raise ValueError(\"Length must be positive.\")\n\n    pools: List[str] = []\n    mandatory: List[str] = []\n\n    if uppercase:\n        pools.append(string.ascii_uppercase)\n        mandatory.append(random.choice(string.ascii_uppercase))\n    if lowercase:\n        pools.append(string.ascii_lowercase)\n        mandatory.append(random.choice(string.ascii_lowercase))\n    if digits:\n        pools.append(string.digits)\n        mandatory.append(random.choice(string.digits))\n    if symbols:\n        pools.append(string.punctuation)\n        mandatory.append(random.choice(string.punctuation))\n\n    all_chars = \"\".join(pools)\n    if len(all_chars) == 0:\n        raise ValueError(\"No characters available for password generation.\")\n\n    remaining_length = max(length - len(mandatory), 0)\n    password_chars = mandatory + [random.choice(all_chars) for _ in range(remaining_length)]\n    random.shuffle(password_chars)\n    return \"\".join(password_chars)\n```\n<ANS_END>", "final_answer": "\n```python\nimport random\nimport string\nfrom typing import List\n\ndef generate_password(\n    length: int = 12,\n    uppercase: bool = True,\n    lowercase: bool = True,\n    digits: bool = True,\n    symbols: bool = True,\n) -> str:\n    \"\"\"\n    Generate a random password satisfying the given constraints.\n\n    Parameters\n    ----------\n    length : int\n        Desired password length.\n    uppercase : bool\n        Include uppercase letters.\n    lowercase : bool\n        Include lowercase letters.\n    digits : bool\n        Include digits.\n    symbols : bool\n        Include punctuation symbols.\n\n    Returns\n    -------\n    str\n        Generated password.\n\n    Raises\n    ------\n    ValueError\n        If no character categories are selected or length is too short.\n    \"\"\"\n    if not any([uppercase, lowercase, digits, symbols]):\n        raise ValueError(\"At least one character type must be selected.\")\n    if length < 1:\n        raise ValueError(\"Length must be positive.\")\n\n    pools: List[str] = []\n    mandatory: List[str] = []\n\n    if uppercase:\n        pools.append(string.ascii_uppercase)\n        mandatory.append(random.choice(string.ascii_uppercase))\n    if lowercase:\n        pools.append(string.ascii_lowercase)\n        mandatory.append(random.choice(string.ascii_lowercase))\n    if digits:\n        pools.append(string.digits)\n        mandatory.append(random.choice(string.digits))\n    if symbols:\n        pools.append(string.punctuation)\n        mandatory.append(random.choice(string.punctuation))\n\n    all_chars = \"\".join(pools)\n    if len(all_chars) == 0:\n        raise ValueError(\"No characters available for password generation.\")\n\n    remaining_length = max(length - len(mandatory), 0)\n    password_chars = mandatory + [random.choice(all_chars) for _ in range(remaining_length)]\n    random.shuffle(password_chars)\n    return \"\".join(password_chars)\n```\n"}
{"question": "Implement a run\u2011length encoding function `rle_encode(s)` that compresses a string by replacing consecutive repeated characters with the character followed by the count. Also provide a decoder `rle_decode(encoded)`.", "answer": "1. For encode: iterate string, count repeats, append char+count.  \n2. For decode: parse digits after each char and repeat char count times.\n\n<ANS_START>\n```python\nimport re\nfrom typing import List\n\ndef rle_encode(s: str) -> str:\n    \"\"\"\n    Run\u2011length encode a string.\n\n    Parameters\n    ----------\n    s : str\n        Input string.\n\n    Returns\n    -------\n    str\n        Encoded string, e.g., 'aaabb' -> 'a3b2'.\n    \"\"\"\n    if not s:\n        return \"\"\n    result: List[str] = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            result.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    result.append(f\"{s[-1]}{count}\")\n    return \"\".join(result)\n\ndef rle_decode(encoded: str) -> str:\n    \"\"\"\n    Decode a run\u2011length encoded string.\n\n    Parameters\n    ----------\n    encoded : str\n        Encoded string.\n\n    Returns\n    -------\n    str\n        Decoded original string.\n    \"\"\"\n    if not encoded:\n        return \"\"\n    parts = re.findall(r\"([A-Za-z])(\\d+)\", encoded)\n    return \"\".join(char * int(count) for char, count in parts)\n```\n<ANS_END>", "final_answer": "\n```python\nimport re\nfrom typing import List\n\ndef rle_encode(s: str) -> str:\n    \"\"\"\n    Run\u2011length encode a string.\n\n    Parameters\n    ----------\n    s : str\n        Input string.\n\n    Returns\n    -------\n    str\n        Encoded string, e.g., 'aaabb' -> 'a3b2'.\n    \"\"\"\n    if not s:\n        return \"\"\n    result: List[str] = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            result.append(f\"{s[i - 1]}{count}\")\n            count = 1\n    result.append(f\"{s[-1]}{count}\")\n    return \"\".join(result)\n\ndef rle_decode(encoded: str) -> str:\n    \"\"\"\n    Decode a run\u2011length encoded string.\n\n    Parameters\n    ----------\n    encoded : str\n        Encoded string.\n\n    Returns\n    -------\n    str\n        Decoded original string.\n    \"\"\"\n    if not encoded:\n        return \"\"\n    parts = re.findall(r\"([A-Za-z])(\\d+)\", encoded)\n    return \"\".join(char * int(count) for char, count in parts)\n```\n"}
{"question": "Write a function `paginate(items, page, per_page)` that returns a slice of `items` corresponding to the requested page number and items per page. Validate inputs and raise `ValueError` for invalid page numbers.", "answer": "1. Ensure `page` and `per_page` are positive integers.  \n2. Compute start and end indices.  \n3. Return slice; if start beyond list length, return empty list.\n\n<ANS_START>\n```python\nfrom typing import List, Any\n\ndef paginate(items: List[Any], page: int, per_page: int) -> List[Any]:\n    \"\"\"\n    Return a page of items from a list.\n\n    Parameters\n    ----------\n    items : list\n        List of items to paginate.\n    page : int\n        1\u2011based page number.\n    per_page : int\n        Number of items per page.\n\n    Returns\n    -------\n    list\n        Sublist corresponding to the requested page.\n\n    Raises\n    ------\n    ValueError\n        If page or per_page is not a positive integer.\n    \"\"\"\n    if page < 1 or per_page < 1:\n        raise ValueError(\"page and per_page must be positive integers.\")\n    start = (page - 1) * per_page\n    end = start + per_page\n    return items[start:end]\n```\n<ANS_END>", "final_answer": "\n```python\nfrom typing import List, Any\n\ndef paginate(items: List[Any], page: int, per_page: int) -> List[Any]:\n    \"\"\"\n    Return a page of items from a list.\n\n    Parameters\n    ----------\n    items : list\n        List of items to paginate.\n    page : int\n        1\u2011based page number.\n    per_page : int\n        Number of items per page.\n\n    Returns\n    -------\n    list\n        Sublist corresponding to the requested page.\n\n    Raises\n    ------\n    ValueError\n        If page or per_page is not a positive integer.\n    \"\"\"\n    if page < 1 or per_page < 1:\n        raise ValueError(\"page and per_page must be positive integers.\")\n    start = (page - 1) * per_page\n    end = start + per_page\n    return items[start:end]\n```\n"}
{"question": "Implement a function `levenshtein_distance(s1, s2)` that computes the Levenshtein distance between two strings. Use dynamic programming for efficiency.", "answer": "1. Create matrix of size (len(s1)+1) x (len(s2)+1).  \n2. Initialize first row/col.  \n3. Fill matrix with min of delete, insert, replace.  \n4. Return bottom\u2011right cell.\n\n<ANS_START>\n```python\nfrom typing import List\n\ndef levenshtein_distance(s1: str, s2: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two strings.\n\n    Parameters\n    ----------\n    s1 : str\n        First string.\n    s2 : str\n        Second string.\n\n    Returns\n    -------\n    int\n        Minimum number of single\u2011character edits required to transform s1 into s2.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n\n    # Initialize matrix\n    dp: List[List[int]] = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # Compute distances\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if s1[i - 1] == s2[j - 1] else 1\n            dp[i][j] = min(\n                dp[i - 1][j] + 1,      # deletion\n                dp[i][j - 1] + 1,      # insertion\n                dp[i - 1][j - 1] + cost  # substitution\n            )\n    return dp[m][n]\n```\n<ANS_END>", "final_answer": "\n```python\nfrom typing import List\n\ndef levenshtein_distance(s1: str, s2: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two strings.\n\n    Parameters\n    ----------\n    s1 : str\n        First string.\n    s2 : str\n        Second string.\n\n    Returns\n    -------\n    int\n        Minimum number of single\u2011character edits required to transform s1 into s2.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    if m == 0:\n        return n\n    if n == 0:\n        return m\n\n    # Initialize matrix\n    dp: List[List[int]] = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # Compute distances\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if s1[i - 1] == s2[j - 1] else 1\n            dp[i][j] = min(\n                dp[i - 1][j] + 1,      # deletion\n                dp[i][j - 1] + 1,      # insertion\n                dp[i - 1][j - 1] + cost  # substitution\n            )\n    return dp[m][n]\n```\n"}
